WEBVTT

1
00:00:00.000 --> 00:00:02.850
As a developer, your
main task will be to

2
00:00:02.850 --> 00:00:05.145
write code to suit
business needs.

3
00:00:05.145 --> 00:00:06.660
That code will have to go

4
00:00:06.660 --> 00:00:08.505
through what's
called refactoring.

5
00:00:08.505 --> 00:00:11.445
This means that you
rewrite or rework the code

6
00:00:11.445 --> 00:00:14.640
to make it easier to manage
or to run more efficiently.

7
00:00:14.640 --> 00:00:16.800
Refactoring is a standard part

8
00:00:16.800 --> 00:00:18.675
of the software
development cycle.

9
00:00:18.675 --> 00:00:20.670
Making code easier to manage,

10
00:00:20.670 --> 00:00:22.650
maybe straightforward,
but what about

11
00:00:22.650 --> 00:00:25.290
making it faster or
making it perform better?

12
00:00:25.290 --> 00:00:28.635
To determine how to make code
faster or perform better,

13
00:00:28.635 --> 00:00:30.480
you must be able to measure it.

14
00:00:30.480 --> 00:00:33.345
Code is measured
by time and space.

15
00:00:33.345 --> 00:00:35.880
Time is measured by
how long it takes

16
00:00:35.880 --> 00:00:38.805
and space is about how
much memory it uses.

17
00:00:38.805 --> 00:00:41.700
Big O notation has
different complexities

18
00:00:41.700 --> 00:00:44.610
or categories ranging from
horrible to excellent.

19
00:00:44.610 --> 00:00:47.475
It's used to measure an
algorithm's efficiency

20
00:00:47.475 --> 00:00:49.590
in terms of time and space.

21
00:00:49.590 --> 00:00:53.220
Let's explore the different
kinds of time complexities.

22
00:00:53.220 --> 00:00:55.260
First, constant time.

23
00:00:55.260 --> 00:00:57.780
This is an algorithm that
will always run under

24
00:00:57.780 --> 00:01:00.630
the same time and space
regardless of the size.

25
00:01:00.630 --> 00:01:02.730
Take a dictionary, for example.

26
00:01:02.730 --> 00:01:04.380
To get the value of an item,

27
00:01:04.380 --> 00:01:05.760
you need to have the key.

28
00:01:05.760 --> 00:01:08.160
The key is a direct
pointer to the value

29
00:01:08.160 --> 00:01:10.920
and does not require any
iteration is to find it.

30
00:01:10.920 --> 00:01:13.080
It's considered constant.

31
00:01:13.080 --> 00:01:15.705
Second is a linear
time algorithm.

32
00:01:15.705 --> 00:01:18.555
This will grow depending
on the size of the input.

33
00:01:18.555 --> 00:01:20.670
For example, if I have an array

34
00:01:20.670 --> 00:01:22.560
of numbers with a range of 100,

35
00:01:22.560 --> 00:01:24.495
it will run very fast.

36
00:01:24.495 --> 00:01:26.415
But if it's increased
to a million,

37
00:01:26.415 --> 00:01:28.620
it will take a lot
longer to complete.

38
00:01:28.620 --> 00:01:30.120
The size in this case,

39
00:01:30.120 --> 00:01:32.190
affects the running
time of the code.

40
00:01:32.190 --> 00:01:35.310
Third, a logarithmic
time algorithm refers to

41
00:01:35.310 --> 00:01:36.675
the running time of the inputs

42
00:01:36.675 --> 00:01:38.790
against the number
of operations.

43
00:01:38.790 --> 00:01:40.890
I can take a linear
approach to try

44
00:01:40.890 --> 00:01:43.200
to find a number out of 100.

45
00:01:43.200 --> 00:01:45.675
Let's say the number is 97.

46
00:01:45.675 --> 00:01:47.250
In a linear equation,

47
00:01:47.250 --> 00:01:50.430
it will take 96 iterations
before it's found.

48
00:01:50.430 --> 00:01:52.515
This is because it
must iterate through

49
00:01:52.515 --> 00:01:56.190
each item one by one until
it finds the target value.

50
00:01:56.190 --> 00:01:58.185
Using a binary search,

51
00:01:58.185 --> 00:01:59.820
I can drastically cut down

52
00:01:59.820 --> 00:02:02.790
the iterations and find it
on the seven iterations.

53
00:02:02.790 --> 00:02:05.490
This is measured by
logarithmic time.

54
00:02:05.490 --> 00:02:07.410
The binary search works by

55
00:02:07.410 --> 00:02:09.180
splitting the list
into two parts

56
00:02:09.180 --> 00:02:11.070
each time to check
if a target is

57
00:02:11.070 --> 00:02:13.560
less than or greater than one.

58
00:02:13.560 --> 00:02:16.380
Fourth, quadratic time refers to

59
00:02:16.380 --> 00:02:17.505
a linear operation of

60
00:02:17.505 --> 00:02:20.100
each value of the
input data squared.

61
00:02:20.100 --> 00:02:22.125
This is often a nested list,

62
00:02:22.125 --> 00:02:23.895
as in this for loop.

63
00:02:23.895 --> 00:02:27.000
This for loop is considered
quadratic time as

64
00:02:27.000 --> 00:02:28.290
the outer loop will need to

65
00:02:28.290 --> 00:02:31.035
iterate in a linear
way 10 times.

66
00:02:31.035 --> 00:02:33.650
But it also has to iterate
the inner loop the

67
00:02:33.650 --> 00:02:36.860
same 10 times for each
single outer loop.

68
00:02:36.860 --> 00:02:39.210
This means it's
total iterations are

69
00:02:39.210 --> 00:02:41.760
10 times 10, which is 100.

70
00:02:41.760 --> 00:02:44.435
Fifth and last is
exponential time,

71
00:02:44.435 --> 00:02:47.570
which is an algorithm that
doubles with each iteration.

72
00:02:47.570 --> 00:02:51.445
The Fibonacci sequence is
a prime example of this.

73
00:02:51.445 --> 00:02:54.455
Refactoring code
can be a big task,

74
00:02:54.455 --> 00:02:57.440
but understanding algorithmic
complexity and how it's

75
00:02:57.440 --> 00:03:00.785
calculated makes it
easier to optimize code.

76
00:03:00.785 --> 00:03:03.365
Now that you know
about constant linear,

77
00:03:03.365 --> 00:03:04.820
logarithmic, quadratic,

78
00:03:04.820 --> 00:03:06.170
and exponential time,

79
00:03:06.170 --> 00:03:09.990
you're one step closer to your
goal of being a developer.